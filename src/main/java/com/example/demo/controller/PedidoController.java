package com.example.demo.controller;

import com.example.demo.model.Pedido;
import com.example.demo.repository.MaquinaRepository;
import com.example.demo.repository.PedidoRepository;
import com.example.demo.repository.CorteRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Controller
@RequestMapping("/pedidos")
public class PedidoController {

    @Autowired
    private PedidoRepository pedidoRepository;

    @Autowired
    private MaquinaRepository maquinaRepository;

    @Autowired
    private CorteRepository corteRepository;

    // ‚úÖ Mostrar pedidos
    @GetMapping
    public String mostrarPedidos(Model model) {
        List<Pedido> pedidos = pedidoRepository.findAll();

        for (Pedido pedido : pedidos) {
            String medida = pedido.getMedidasSabanas();

            int juegosCorte = corteRepository.contarJuegosCortadosPorPedido(pedido.getId());

            int planas = maquinaRepository.contarPorPedidoYTipo(pedido.getId(), "Plana");
            int cauchos = maquinaRepository.contarPorPedidoYTipo(pedido.getId(), "Caucho");
            int fundas = maquinaRepository.contarPorPedidoYTipo(pedido.getId(), "Fundas");

            int juegosMaquina = Math.min(planas, Math.min(cauchos, fundas / 2));

            double progresoCorte = (double) juegosCorte / pedido.getJuegos() * 30;
            double progresoMaquina = (double) juegosMaquina / pedido.getJuegos() * 40;
            double progresoEmpaque = (double) pedido.getCantidadEntregada() / pedido.getJuegos() * 30;

            double porcentajeTotal = progresoCorte + progresoMaquina + progresoEmpaque;

            pedido.setProgresoCorte(progresoCorte);
            pedido.setProgresoMaquina(progresoMaquina);
            pedido.setProgresoEmpaque(progresoEmpaque);
            pedido.setPorcentajeTotal(Math.min(porcentajeTotal, 100.0));
        }

        model.addAttribute("pedidos", pedidos);

        List<Pedido> pedidosCompletados = pedidos.stream()
                .filter(p -> p.getCantidadEntregada() >= p.getJuegos())
                .sorted((p1, p2) -> p1.getId().compareTo(p2.getId()))
                .toList();

        List<String> etiquetas = pedidosCompletados.stream()
                .map(p -> "Pedido " + p.getId())
                .toList();

        List<Integer> cantidades = pedidosCompletados.stream()
                .map(Pedido::getCantidadEntregada)
                .toList();

        model.addAttribute("etiquetas", etiquetas);
        model.addAttribute("cantidades", cantidades);

        return "pedido";
    }

    // ‚úÖ Registrar nuevo pedido
    @PostMapping("/registrar")
    public String registrarPedido(
            @RequestParam String medidasSabanas,
            @RequestParam int juegos,
            @RequestParam String fechaEnvio,
            RedirectAttributes redirectAttributes) {

        try {
            if (medidasSabanas == null || medidasSabanas.trim().isEmpty()) {
                redirectAttributes.addFlashAttribute("error", "‚ùå La medida de s√°banas es obligatoria");
                return "redirect:/pedidos";
            }

            LocalDate fechaEntrega;
            try {
                fechaEntrega = LocalDate.parse(fechaEnvio);
            } catch (Exception e) {
                redirectAttributes.addFlashAttribute("error", "‚ùå Formato de fecha inv√°lido. Use YYYY-MM-DD");
                return "redirect:/pedidos";
            }

            if (fechaEntrega.isBefore(LocalDate.now())) {
                redirectAttributes.addFlashAttribute("error", "‚ùå La fecha de entrega no puede ser anterior a hoy");
                return "redirect:/pedidos";
            }

            if (juegos <= 0) {
                redirectAttributes.addFlashAttribute("error", "‚ùå La cantidad de juegos debe ser mayor a 0");
                return "redirect:/pedidos";
            }

            List<Pedido> pedidosIncompletos = pedidoRepository.findPedidosIncompletosPorMedida(medidasSabanas);

            if (!pedidosIncompletos.isEmpty()) {
                Pedido pedidoIncompleto = pedidosIncompletos.get(0);
                int faltantes = pedidoIncompleto.getJuegos() - pedidoIncompleto.getCantidadEntregada();

                redirectAttributes.addFlashAttribute("error",
                        String.format(
                                "‚ùå Existe un pedido incompleto para '%s'. Pedido ID: %d - Faltan %d juegos de %d total. Complete este pedido antes de crear uno nuevo.",
                                medidasSabanas, pedidoIncompleto.getId(), faltantes, pedidoIncompleto.getJuegos()));
                return "redirect:/pedidos";
            }

            Pedido pedido = new Pedido();
            pedido.setMedidasSabanas(medidasSabanas.trim());
            pedido.setJuegos(juegos);
            pedido.setFechaEnvio(fechaEntrega);
            pedido.setCantidadEntregada(0);

            Pedido pedidoGuardado = pedidoRepository.save(pedido);

            redirectAttributes.addFlashAttribute("mensaje",
                    String.format(
                            "‚úÖ Pedido registrado exitosamente. ID: %d | Juegos: %d | Medida: %s | Fecha entrega: %s",
                            pedidoGuardado.getId(), juegos, medidasSabanas, fechaEntrega));

        } catch (Exception e) {
            redirectAttributes.addFlashAttribute("error", "‚ùå Error al registrar el pedido: " + e.getMessage());
            e.printStackTrace();
        }

        return "redirect:/pedidos";
    }

    // ‚úÖ Validar producci√≥n en m√°quina
    @PostMapping("/validar-produccion-maquina")
    @ResponseBody
    public ValidationResult validarProduccionMaquina(
            @RequestParam String medidasSabanas,
            @RequestParam String tipoSabana,
            @RequestParam int cantidadNueva) {

        try {
            List<Pedido> pedidosActivos = pedidoRepository.findPedidosIncompletosPorMedida(medidasSabanas);

            if (pedidosActivos.isEmpty()) {
                return new ValidationResult(false, "‚ùå No hay pedidos activos para la medida: " + medidasSabanas);
            }

            int totalJuegosSolicitados = pedidosActivos.stream()
                    .mapToInt(Pedido::getJuegos)
                    .sum();

            LocalDate fechaInicio = LocalDate.now().minusDays(60);
            int planasActuales = maquinaRepository.contarPorMedidaYTipoDesde(medidasSabanas, "Plana", fechaInicio);
            int cauchosActuales = maquinaRepository.contarPorMedidaYTipoDesde(medidasSabanas, "Caucho", fechaInicio);
            int fundasActuales = maquinaRepository.contarPorMedidaYTipoDesde(medidasSabanas, "Fundas", fechaInicio);

            int limitePlanas = totalJuegosSolicitados;
            int limiteCauchos = totalJuegosSolicitados;
            int limiteFundas = totalJuegosSolicitados * 2;

            int nuevasPlanas = planasActuales + (tipoSabana.equals("Plana") ? cantidadNueva : 0);
            int nuevosCauchos = cauchosActuales + (tipoSabana.equals("Caucho") ? cantidadNueva : 0);
            int nuevasFundas = fundasActuales + (tipoSabana.equals("Fundas") ? cantidadNueva : 0);

            if (nuevasPlanas > limitePlanas) {
                int maxPermitido = limitePlanas - planasActuales;
                return new ValidationResult(false,
                        "üö® Exceso de planas para " + medidasSabanas +
                                ". M√°ximo permitido: " + Math.max(0, maxPermitido));
            }

            if (nuevosCauchos > limiteCauchos) {
                int maxPermitido = limiteCauchos - cauchosActuales;
                return new ValidationResult(false,
                        "üö® Exceso de cauchos para " + medidasSabanas +
                                ". M√°ximo permitido: " + Math.max(0, maxPermitido));
            }

            if (nuevasFundas > limiteFundas) {
                int maxPermitido = limiteFundas - fundasActuales;
                return new ValidationResult(false,
                        "üö® Exceso de fundas para " + medidasSabanas +
                                ". M√°ximo permitido: " + Math.max(0, maxPermitido));
            }

            return new ValidationResult(true, "‚úÖ Producci√≥n v√°lida para " + medidasSabanas);

        } catch (Exception e) {
            return new ValidationResult(false, "‚ùå Error en validaci√≥n: " + e.getMessage());
        }
    }

    // ‚úÖ Validar producci√≥n en empaque
    @PostMapping("/validar-produccion-empaque")
    @ResponseBody
    public ValidationResult validarProduccionEmpaque(
            @RequestParam String medidasSabanas,
            @RequestParam int cantidadNueva) {

        try {
            List<Pedido> pedidosActivos = pedidoRepository.findPedidosIncompletosPorMedida(medidasSabanas);

            if (pedidosActivos.isEmpty()) {
                return new ValidationResult(false, "‚ùå No hay pedidos activos para la medida: " + medidasSabanas);
            }

            int totalJuegosSolicitados = pedidosActivos.stream()
                    .mapToInt(Pedido::getJuegos)
                    .sum();

            int juegosYaEntregados = pedidosActivos.stream()
                    .mapToInt(Pedido::getCantidadEntregada)
                    .sum();

            if (juegosYaEntregados + cantidadNueva > totalJuegosSolicitados) {
                int maxPermitido = totalJuegosSolicitados - juegosYaEntregados;
                return new ValidationResult(false,
                        "üö® Exceso de juegos. Solo puedes registrar " + Math.max(0, maxPermitido) + " juegos m√°s.");
            }

            return new ValidationResult(true, "‚úÖ Producci√≥n v√°lida para empaque.");

        } catch (Exception e) {
            return new ValidationResult(false, "‚ùå Error en validaci√≥n: " + e.getMessage());
        }
    }

    // ‚úÖ Validar producci√≥n en corte
    @PostMapping("/validar-produccion-corte")
    @ResponseBody
    public ValidationResult validarProduccionCorte(
            @RequestParam String medidasSabanas,
            @RequestParam int juegosCompletados) {

        try {
            if (juegosCompletados != 1) {
                return new ValidationResult(false, "‚ùå Solo puedes registrar un juego a la vez.");
            }

            List<Pedido> pedidosActivos = pedidoRepository.findPedidosIncompletosPorMedida(medidasSabanas);

            if (pedidosActivos.isEmpty()) {
                return new ValidationResult(false, "‚ùå No hay pedidos activos para la medida: " + medidasSabanas);
            }

            int totalJuegosSolicitados = pedidosActivos.stream()
                    .mapToInt(Pedido::getJuegos)
                    .sum();

            int juegosYaEntregados = pedidosActivos.stream()
                    .mapToInt(Pedido::getCantidadEntregada)
                    .sum();

            if (juegosYaEntregados + juegosCompletados > totalJuegosSolicitados) {
                int maxPermitido = totalJuegosSolicitados - juegosYaEntregados;
                return new ValidationResult(false, "üö® Exceso de juegos completos. Solo puedes registrar "
                        + Math.max(0, maxPermitido) + " juego(s) m√°s.");
            }

            for (Pedido pedido : pedidosActivos) {
                int juegosFaltantes = pedido.getJuegos() - pedido.getCantidadEntregada();

                if (juegosFaltantes <= 0)
                    continue;

                pedido.setCantidadEntregada(pedido.getCantidadEntregada() + 1);
                pedidoRepository.save(pedido);
                break;
            }

            int juegosRestantes = totalJuegosSolicitados - (juegosYaEntregados + 1);

            return new ValidationResult(true,
                    "‚úÖ Registro exitoso. Has entregado 1 juego. Quedan " + juegosRestantes + " juego(s) pendientes.");

        } catch (Exception e) {
            return new ValidationResult(false, "‚ùå Error en validaci√≥n: " + e.getMessage());
        }
    }

    // ‚úÖ Actualizar cantidad entregada
    @PostMapping("/actualizar-entrega")
    public String actualizarEntrega(
            @RequestParam Long pedidoId,
            @RequestParam int cantidadNueva,
            RedirectAttributes redirectAttributes) {

        try {
            Optional<Pedido> pedidoOpt = pedidoRepository.findById(pedidoId);

            if (pedidoOpt.isEmpty()) {
                redirectAttributes.addFlashAttribute("error", "‚ùå Pedido no encontrado");
                return "redirect:/pedidos";
            }

            Pedido pedido = pedidoOpt.get();

            if (pedido.getCantidadEntregada() + cantidadNueva > pedido.getJuegos()) {
                int maxPermitido = pedido.getJuegos() - pedido.getCantidadEntregada();
                redirectAttributes.addFlashAttribute("error",
                        "‚ùå No puedes entregar m√°s de lo solicitado. M√°ximo: " + maxPermitido + " juegos");
                return "redirect:/pedidos";
            }

            pedido.setCantidadEntregada(pedido.getCantidadEntregada() + cantidadNueva);
            pedidoRepository.save(pedido);

            String estadoPedido = pedido.getCantidadEntregada() >= pedido.getJuegos() ? "COMPLETADO" : "PENDIENTE";

            redirectAttributes.addFlashAttribute("mensaje",
                    "‚úÖ Entrega actualizada. Pedido ID: " + pedidoId + " | Entregados: " + pedido.getCantidadEntregada()
                            + "/" + pedido.getJuegos() + " | Estado: " + estadoPedido);

        } catch (Exception e) {
            redirectAttributes.addFlashAttribute("error", "‚ùå Error al actualizar entrega: " + e.getMessage());
        }

        return "redirect:/pedidos";
    }

    // ‚úÖ Clase para validaciones
    public static class ValidationResult {
        private boolean valid;
        private String message;

        public ValidationResult(boolean valid, String message) {
            this.valid = valid;
            this.message = message;
        }

        public boolean isValid() {
            return valid;
        }

        public String getMessage() {
            return message;
        }
    }
}
